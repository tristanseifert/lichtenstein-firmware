/*
 * CPULoadProfiler.cpp
 *
 *  Created on: Feb 16, 2018
 *      Author: tristan
 */
#include "CPULoadProfiler.h"
#include "System.h"

#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"

#include "cmsis_device.h"

#if HW == HW_MUSTARD

// RCC clock for the timer we're using
#define CPU_TIM_RCC_CLOCK					RCC_APB1Periph_TIM5
// what timer peripheral to use
#define CPU_TIM_PERIPHERAL					TIM5
// timer prescaler (~63,943Hz)
#define CPU_TIM_PRESCALER					(563)
// this is the value on which the timer raises an interrupt
#define CPU_TIM_EXPIRE						0xFFFF

// IRQ fired by the timer
#define CPU_TIM_IRQ							TIM5_IRQn
// priority of the IRQ generated by the CPU timer
#define CPU_TIM_IRQ_PRIORITY					(configMAX_SYSCALL_INTERRUPT_PRIORITY >> 4)
// name of the ISR used for the timer
#define CPU_TIM_ISR_NAME						TIM5_IRQHandler

#endif

namespace sys {

/**
 * Sets up the profiling timers. This uses TIM5, which is clocked at 36MHz.
 */
CPULoadProfiler::CPULoadProfiler() {
	TIM_TimeBaseInitTypeDef tim;
	TIM_TimeBaseStructInit(&tim);

	// enable the clock to the timer
	RCC_APB1PeriphClockCmd(CPU_TIM_RCC_CLOCK, ENABLE);

	// initialize the timer
	tim.TIM_Prescaler = CPU_TIM_PRESCALER;
	tim.TIM_CounterMode = TIM_CounterMode_Up;
	tim.TIM_Period = CPU_TIM_EXPIRE;
	tim.TIM_ClockDivision = TIM_CKD_DIV1;
	tim.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(CPU_TIM_PERIPHERAL, &tim);
	TIM_Cmd(CPU_TIM_PERIPHERAL, ENABLE);

	// enable the update interrupt
	TIM_ITConfig(CPU_TIM_PERIPHERAL, TIM_IT_Update, ENABLE);

	NVIC_InitTypeDef nvic;
	nvic.NVIC_IRQChannelSubPriority = 0x0F;
	nvic.NVIC_IRQChannelCmd = ENABLE;
	nvic.NVIC_IRQChannel = CPU_TIM_IRQ;
	nvic.NVIC_IRQChannelPreemptionPriority = CPU_TIM_IRQ_PRIORITY;

	NVIC_Init(&nvic);
}

/**
 * Kill the timers.
 */
CPULoadProfiler::~CPULoadProfiler() {

}


/**
 * ISR handler for the timer.
 */
void _CPULoadProfilerTimerISR(void) {
	CPULoadProfiler &p = System::sharedInstance()->cpuLoad;

	if (TIM_GetITStatus(CPU_TIM_PERIPHERAL, TIM_IT_Update) != RESET) {
		// clear flag
		TIM_ClearITPendingBit(CPU_TIM_PERIPHERAL, TIM_IT_Update);

		// are we currently in the idle task?
		if(p.isInIdleTask) {
			// if so, keep track of the time during this slice and reset it
			p.idleTime += CPU_TIM_EXPIRE - p.lastTimerValueOnIdleEnter;
			p.lastTimerValueOnIdleEnter = 0;
		} else {
			// we don't have to do anything here
		}

		// reset the idle time value
		p.lastIdleTime = p.idleTime;
		p.idleTime = 0;

		// convert the idle time value into a percentage
//		trace_printf("Time spent in idle task: %u\n", p->lastIdleTime);
		p.lastIdleTime = (p.lastIdleTime / (CPU_TIM_EXPIRE / 100));
	}
}

extern "C" void CPU_TIM_ISR_NAME(void) {
	_CPULoadProfilerTimerISR();
}



/**
 * Right after the task is switched, this function is invoked.
 */
void _CPULoadProfilerContextSwitch() {
	System::sharedInstance()->cpuLoad.handleContextSwitchFromKernel();
}

extern "C" void _CPULoadProfilerTaskSwitchedIn() {
	taskENTER_CRITICAL();
	_CPULoadProfilerContextSwitch();
	taskEXIT_CRITICAL();
}

/**
 * Called after a new task has been switched in. Check if the task that was
 * switched in was the idle task: if so, record the current timer value and
 * set a flag. The next time a context switch occurs to another task, add the
 * difference between the new timer value and the last one and clear a flag.
 */
void CPULoadProfiler::handleContextSwitchFromKernel() {
	int counter = TIM_GetCounter(CPU_TIM_PERIPHERAL);

	TaskHandle_t idleHandle = xTaskGetIdleTaskHandle();
	TaskHandle_t currentHandle = xTaskGetCurrentTaskHandle();

	// did we switch to the idle task?
	if(idleHandle == currentHandle) {
		this->isInIdleTask = true;
		this->lastTimerValueOnIdleEnter = counter;
	}
	// we switched to another task.
	else {
		// was the last task the idle task?
		if(this->isInIdleTask == true) {
			// clear the flag
			this->isInIdleTask = false;

			// add the difference to the idle time counter
			this->idleTime += counter - this->lastTimerValueOnIdleEnter;
		}
	}
}

/**
 * Returns the value of the high-resolution timer.
 */
/*extern "C" unsigned int _CPULoadProfilerGetTimerValue() {
	return TIM_GetCounter(CPU_TIM_PERIPHERAL);
}*/

} /* namespace sys */
